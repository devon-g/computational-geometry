Chapter 1. Convex Hull

Our algorithm today - let's call it MediumConvexHull (see Exercise 1.7) - is
neither SlowConvexHull nor ConvexHull from the book.

Divide up the following work so that it all gets done.

    1. Implement ConvexHull from the book and be prepared to explain it.

    2. Implement MediumConvexHull and explain why it's faster than
        SlowConvexHull.

        SlowConvexHull nests looping through all the points 3 times and
        MediumConvexHull nests looping through all the points twice.

    3. Understand the book's discussion of robustness and whether its two
        algorithms are robust. Show that ConvexHull is robust, by finding an
        input where ConvexHull computes an answer that is (i) incorrect but (ii)
        close to the correct answer.

        ConvexHull computes an answer that is incorrect when there are three
        colinear points on the convex hull. The algorithm will not include the
        middle vertex in the convex hull but will still be close to the correct
        answer because the convex hull still passes through that point.

    4. Is MediumConvexHull robust? Give an argument that it either does or
        doesn't always output a nearly convex polygon; can the bad examples of
        page 5, or any other bad outcomes, occur? (Exercise 1.7e)

        MediumConvexHull does not always output a nearly convex polygon. 
        Nearly colinear points may result in a point being falsely included
        or excluded due to floating point rounding errors.

    5. Try to find an input where MediumConvexHull computes an answer that is
        incorrect. See how close it is to the correct answer.

        Suppose we have two vertices on the convex hull (0, 1) and (2, 1) with
        a third point (1, 1.0000000000000000000000000000000000000000000000001).
        Floating point rounding errors could result in the this third point being
        included in the convex hull when it should be excluded.

    6. Which is faster in practice, MediumConvexHull or ConvexHull? Test them
        on n points, 2n points, 4n points, etc., where n is some number that
        gives informative results, and graph the running times.

    7. Exercise 1.3.

    8. Exercise 1.8. A description, not an implementation.
    
    9. Exercise 1.10. You might want to brainstorm this.

Read Chapter 2 and be ready to discuss it.
